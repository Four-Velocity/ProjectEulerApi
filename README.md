# ProjectEulerApi

Api for retrieving ProjectEuler problems and verify solutions

## Short specs

### API

API must include endpoints for retrieving
[ProjectEuler](https://projecteuler.net/) problems and checking
solutions.  
For retrieving problems we can use:

```rest
https://example.com/problems/
LIST
{
    "data": [
        {"id": XXX, "text": "Lorem ipsum ...", "link": "https://projecteuler.net/problem=xxx"},
        {"id": XXX, "text": "... dolor sit amet...", "link": "https://projecteuler.net/problem=xxx"},
        ...
    ],
    "meta": {
        "lang": "en",
        "offset": 0,
        "limit": XXX,
    }
}
```

> Allow `offset` and `limit` params in LIST

```rest
https://example.com/problems/{id}/
GET
{
    "id": XXX,
    "text": "Lorem ipsum...",
    "link": "https://projecteuler.net/problem=xxx",
    "lang": "en"
}
```

For checking solutions we can use POST

> We **must never** show the solution itself.

```rest
https://example.com/problems/{id}/check/
POST | REQUEST
{
    "solution": "some_solution"
}
```

```rest
https://example.com/problems/{id}/check/
POST | RESPONSE
{
    "id": XXX,
    "result": true/false
}
```

> The responses are `camelCase` the pydantic model fields are
> `snake_case` chek this out to understand the principles:
> [Medium](https://medium.com/analytics-vidhya/camel-case-models-with-fast-api-and-pydantic-5a8acb6c0eee)

### Translations

The text of the problems must be translatable, and the translations must
be provided in human-readable format to make translation-contributions
easy.

For example, we can use toml, but not sure which way will be better
(problem based or translation based)

#### Problem based way:

**Problem001.toml**

```toml
en = """
If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000."""
ru = """
–ï—Å–ª–∏ –≤—ã–ø–∏—Å–∞—Ç—å –≤—Å–µ –Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã–µ —á–∏—Å–ª–∞ –º–µ–Ω—å—à–µ 10, –∫—Ä–∞—Ç–Ω—ã–µ 3 –∏–ª–∏ 5, —Ç–æ –ø–æ–ª—É—á–∏–º 3, 5, 6 –∏ 9. –°—É–º–º–∞ —ç—Ç–∏—Ö —á–∏—Å–µ–ª —Ä–∞–≤–Ω–∞ 23.

–ù–∞–π–¥–∏—Ç–µ —Å—É–º–º—É –≤—Å–µ—Ö —á–∏—Å–µ–ª –º–µ–Ω—å—à–µ 1000, –∫—Ä–∞—Ç–Ω—ã—Ö 3 –∏–ª–∏ 5."""
```

**Problem002.toml**

```toml
en = """
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms."""

ru = """
–ö–∞–∂–¥—ã–π —Å–ª–µ–¥—É—é—â–∏–π —ç–ª–µ–º–µ–Ω—Ç —Ä—è–¥–∞ –§–∏–±–æ–Ω–∞—á—á–∏ –ø–æ–ª—É—á–∞–µ—Ç—Å—è –ø—Ä–∏ —Å–ª–æ–∂–µ–Ω–∏–∏ –¥–≤—É—Ö –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö. –ù–∞—á–∏–Ω–∞—è —Å 1 –∏ 2, –ø–µ—Ä–≤—ã–µ 10 —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –±—É–¥—É—Ç:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

–ù–∞–π–¥–∏—Ç–µ —Å—É–º–º—É –≤—Å–µ—Ö —á–µ—Ç–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Ä—è–¥–∞ –§–∏–±–æ–Ω–∞—á—á–∏, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –ø—Ä–µ–≤—ã—à–∞—é—Ç —á–µ—Ç—ã—Ä–µ –º–∏–ª–ª–∏–æ–Ω–∞."""
```

#### Translation based way:

**en.toml**

```toml
problem1 = """
If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000."""

problem2 = """
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms."""
```

**ru.toml**

```toml
problem1 = """
–ï—Å–ª–∏ –≤—ã–ø–∏—Å–∞—Ç—å –≤—Å–µ –Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã–µ —á–∏—Å–ª–∞ –º–µ–Ω—å—à–µ 10, –∫—Ä–∞—Ç–Ω—ã–µ 3 –∏–ª–∏ 5, —Ç–æ –ø–æ–ª—É—á–∏–º 3, 5, 6 –∏ 9. –°—É–º–º–∞ —ç—Ç–∏—Ö —á–∏—Å–µ–ª —Ä–∞–≤–Ω–∞ 23.

–ù–∞–π–¥–∏—Ç–µ —Å—É–º–º—É –≤—Å–µ—Ö —á–∏—Å–µ–ª –º–µ–Ω—å—à–µ 1000, –∫—Ä–∞—Ç–Ω—ã—Ö 3 –∏–ª–∏ 5."""

problem2 = """
–ö–∞–∂–¥—ã–π —Å–ª–µ–¥—É—é—â–∏–π —ç–ª–µ–º–µ–Ω—Ç —Ä—è–¥–∞ –§–∏–±–æ–Ω–∞—á—á–∏ –ø–æ–ª—É—á–∞–µ—Ç—Å—è –ø—Ä–∏ —Å–ª–æ–∂–µ–Ω–∏–∏ –¥–≤—É—Ö –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö. –ù–∞—á–∏–Ω–∞—è —Å 1 –∏ 2, –ø–µ—Ä–≤—ã–µ 10 —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –±—É–¥—É—Ç:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

–ù–∞–π–¥–∏—Ç–µ —Å—É–º–º—É –≤—Å–µ—Ö —á–µ—Ç–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Ä—è–¥–∞ –§–∏–±–æ–Ω–∞—á—á–∏, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –ø—Ä–µ–≤—ã—à–∞—é—Ç —á–µ—Ç—ã—Ä–µ –º–∏–ª–ª–∏–æ–Ω–∞."""
```

#### Translation mechanism

On every deploy the translation must be updated from that file to the
database.

The preferred way to do it is:
1. Try to get the problem text from the DB
2. If the problem translation does not exist create the new one
3. If it exist: compare the text hashes from db and from translation
   files. Update only if hashes aren't match

### DB models

![DB_SCHEME](/docs/puml_rendered/db_scheme.png?raw=true)

### Workflow requirements

* All code are covered with unit tests (use pytest pls)
* All linters checks are passed
* All code must be reformatted with black and isort
* Use [gitmoji](https://gitmoji.dev/) in commits
* To make a contribution:
  * Create new branch and make a PR for it. Set its
    status to WIP by adding üöß emoji to the beginning of the PR name. (Use
    emoji, not emoji code)
  * Do everything you have to do
  * After all checks are passes merge you commit to the `main` branch


### Good to have in the future

* Registration with captcha to avoid multiple request from users or add some throtling mechanism
* Token auth
* Docker image to use project locally
